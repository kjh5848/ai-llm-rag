# PART 6. LangChain으로 연결 전략 세팅

## 1. 탄생 배경 (Background)
- **점조직의 한계**: RAG 엔진(검색), MCP 도구(DB 조회), LLM(생성)이 각각 따로 놀면 유기적인 서비스가 불가능함.
- **오케스트레이션 필요성**: 이들을 한 줄로 꿰어서 "질문 -> 판단 -> 검색/조회 -> 답변"이라는 워크플로우를 관리할 **지휘자**가 필요함.

## 2. 개념 (Concept)
- **LangChain**: LLM을 이용한 애플리케이션 개발을 돕는 프레임워크. 다양한 모듈(Model, Prompt, Index, Chain)을 레고 블록처럼 조립 가능.
- **Router (라우터)**: 사용자의 질문을 분석하여 "이건 검색이 필요해", "이건 DB 조회가 필요해"라고 경로를 지정해주는 신호등.
- **Runnable**: LangChain의 모든 컴포넌트가 따르는 표준 인터페이스(invoke, stream, batch).

## 3. 역할 (Role)
- **접착제 (Glue)**: 서로 다른 라이브러리(Chroma, Ollama, SQLAlchemy)를 하나의 인터페이스로 통합.
- **워크플로우 관리자**: 에러 발생 시 재시도(Retry), 스트리밍 응답, 메모리(대화 기록) 관리.

## 4. 도입 이유 (Reason)
- **표준화**: LLM 모델을 GPT-4에서 DeepSeek-R1으로 바꾸더라도 코드 수정(Chain 구조)을 최소화할 수 있음.
- **생산성**: 복잡한 비동기 처리나 프롬프트 관리를 직접 구현하려면 시간이 많이 걸림.

## 5. 장단점 (Pros & Cons)
| 구분 | 내용 |
| :--- | :--- |
| **장점** | - **생태계**: 거의 모든 LLM, VectorDB, Tool과 연동되는 방대한 통합 라이브러리 보유.<br>- **추상화**: 복잡한 로직을 Chain 하나로 묶어서 관리 가능. |
| **단점** | - **러닝커브**: 개념(LCEL 등)이 방대하고 자주 바뀌어서 배우기 어려움.<br>- **오버헤드**: 단순한 API 호출에 비해 코드가 무거워질 수 있음. |

## 6. 차별점 (Differences)
- **vs Raw Python Code**:
  - 직접 짜면 가볍지만, 기능을 추가할 때마다 스파게티 코드가 되기 쉬움. LangChain은 구조화된 확장이 가능.
- **vs LlamaIndex**:
  - LlamaIndex는 **"데이터 인덱싱/검색"**에 특화되어 있고, LangChain은 **"범용적인 앱 로직/Agent"** 구성에 강점이 있음. (둘을 섞어 쓰기도 함)

## 7. 관련 기술 (Related Tech)
- **LCEL (LangChain Expression Language)**: `prompt | llm | parser` 처럼 파이프라인을 선언적으로 작성하는 문법.
- **LangGraph**: 순환(Cycle)이 있는 복잡한 에이전트 흐름을 제어하기 위한 LangChain의 상위 도구.
